# Big O та складність алгоритмів

Big O показує, як змінюється час виконання алгоритму в залежності від розміру даних.

## Типи складності:

- **O(1)** — Константна складність: Час виконання алгоритму не залежить від розміру вхідних даних. Залишається постійним, навіть якщо дані збільшуються.
  - **Приклад:** доступ до елемента масиву за індексом. Незалежно від того, скільки елементів у масиві, час доступу до конкретного елемента завжди однаковий.
  
- **O(n)** — Лінійна складність: Час виконання збільшується пропорційно до розміру вхідних даних. Якщо даних вдвічі більше, час виконання також збільшується вдвічі.
  - **Приклад:** лінійний пошук. Якщо масив містить n елементів, алгоритм має перевірити кожен елемент, щоб знайти потрібний.

- **O(log n)** — Логарифмічна складність: Час виконання зростає дуже повільно, навіть якщо дані значно збільшуються. Це характерно для алгоритмів, які розділяють дані на частини (наприклад, при пошуку).
  - **Приклад:** бінарний пошук у відсортованому масиві. При кожному кроці масив ділиться на дві частини, що значно зменшує кількість перевірок навіть для великих обсягів даних.

- **O(n log n)** — Лінійно-логарифмічна складність: Час виконання зростає повільніше, ніж лінійно, але швидше, ніж просто логарифмічно. Це типова складність для ефективних алгоритмів сортування.
  - **Приклад:** QuickSort або MergeSort. Алгоритм спочатку розділяє дані (логарифмічно), а потім виконує операції на кожному підмасиві (лінійно), що дає лінійно-логарифмічну складність.

- **O(n²)** — Квадратична складність: Час виконання пропорційний квадрату розміру даних. Якщо кількість даних збільшується вдвічі, час виконання зростає в чотири рази.
  - **Приклад:** сортування бульбашкою. Алгоритм порівнює кожен елемент з усіма іншими елементами, що створює велику кількість операцій порівняння для великих даних.

- **O(2^n)** — Експоненціальна складність: Час виконання зростає дуже швидко, і навіть невелике збільшення розміру даних може призвести до значного збільшення часу виконання.
  - **Приклад:** рекурсивне обчислення чисел Фібоначчі. Кожен новий обчислений елемент вимагає двох попередніх, що веде до експоненційного росту операцій.

- **O(n!)** — Факультативна складність: Час виконання зростає надзвичайно швидко, і навіть при помірних розмірах даних може стати непридатним для використання.
  - **Приклад:** задача про перестановки. Кількість можливих перестановок з n елементів дорівнює n!, що робить алгоритм надзвичайно повільним для великих значень n.
